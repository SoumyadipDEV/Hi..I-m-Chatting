<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat App</title>
    <link rel="stylesheet" href="/chat.css">
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<!-- Set initial mode -->
<body class="user-chat-mode">

    <!-- (Toggles moved below chat boxes) -->

    <!-- Original User Chat Container -->
    <div id="user-chat-wrapper" class="flex justify-center items-center h-screen w-full unauth-hidden">
    <div id="chat-container" class="text-center">
            <div class="flex items-center justify-center">
                <h1>Hi.. I'm Chatting</h1>
            </div>
            <div id="messages"></div>

            <!-- Chat Controls: compact toggles placed under the chat box -->
            <div id="chat-controls" class="chat-controls">
                <span id="mode-label" class="label-small">User Chat</span>

                <label class="toggle-switch small-toggle" title="Switch AI/User mode">
                    <input type="checkbox" id="mode-toggle-switch">
                    <span class="slider"></span>
                </label>

                <span class="label-small">Light</span>
                <label class="toggle-switch small-toggle" title="Toggle theme">
                    <input type="checkbox" id="dark-mode-toggle">
                    <span class="slider"></span>
                </label>
                <span class="label-small">Dark</span>
            </div>
            <!-- Input row: text input and send button inline -->
            <div class="mt-5 flex items-center space-x-3">
                <input type="text" placeholder="Enter new message" id="message" class="flex-1 p-2.5 border-2 rounded-sm" />
                <button id="sendBtn" disabled class="px-4 py-3 bg-[#00796b] text-white rounded-full cursor-pointer send-btn font-semibold" aria-label="Send message">
                    <!-- paper-plane SVG icon -->
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                        <path d="M2 21L23 12L2 3L2 10L17 12L2 14L2 21Z" fill="white"/>
                    </svg>
                    <span class="label">Send</span>
                </button>
            </div>
        </div>
    </div>

    <!-- New AI Chat Container (Centered, Initially Hidden) -->
    <div id="ai-chat-container" class="hidden flex justify-center items-center h-screen w-full">
        <div class="w-full max-w-2xl flex flex-col p-4 bg-white rounded-lg shadow-md" style="height: 80vh; background-color: var(--ai-chat-bg, #ffffff); color: var(--ai-text, #1f2937);">
            <h1 class="text-3xl font-bold text-center mb-4" style="color: #00796b;">Gemini AI Chat</h1>
            
            <!-- Chat Messages Area -->
            <div id="ai-messages" class="flex-1 overflow-y-auto p-4 space-y-4 rounded-lg" style="background-color: var(--ai-bg, #f3f4f6);">
                <!-- Messages will be appended here -->
                <div class="ai-message gemini">
                    <div class="bubble">
                        Hi <span id="ai-username" class="font-semibold">User</span>! How can I help you today?
                    </div>
                </div>
            </div>
            
            <!-- Input Area -->
            <div class="mt-4 flex space-x-2">
                <input type="text" id="ai-message-input" placeholder="Ask Gemini..." class="flex-1 px-4 py-3 rounded-full border-2 border-gray-300 focus:outline-none focus:border-teal-500" style="background-color: var(--ai-input-bg, #ffffff); color: var(--ai-text, #000);">
                <button id="ai-send-btn" class="px-4 py-3 rounded-full font-semibold text-white transition-colors send-btn" style="background-color: #00796b; border: none; cursor: pointer;">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                        <path d="M2 21L23 12L2 3L2 10L17 12L2 14L2 21Z" fill="white"/>
                    </svg>
                    <span class="label">Send</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Mobile Menu Toggle Button -->
    <button id="mobile-menu-toggle" class="mobile-menu-toggle" title="Toggle user status panel" aria-label="Toggle menu">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 6h18M3 12h18M3 18h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
    </button>

    <!-- User Status Panel (Collapsible on Mobile) -->
    <div id="user-status" class="user-status-panel">
        <button id="close-status-panel" class="close-status-panel" title="Close panel" aria-label="Close panel">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
        </button>
        <button id="logoutBtn" class="w-full px-3 py-2 mb-3 bg-red-500 text-white rounded text-sm font-semibold hover:bg-red-600 transition">Logout</button>
    </div>
    
    <!-- Mobile Overlay (closes panel when clicked) -->
    <div id="mobile-overlay" class="mobile-overlay"></div>

    <!-- Load Socket.IO client from CDN to fix 'io is not defined' error in environments without the Node.js server -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        // --- UTILITY FUNCTIONS ---
        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }
        
        // --- COMMON ---
        let chatName = '';
    const modeToggle = document.getElementById('mode-toggle-switch');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
        const userChatWrapper = document.getElementById('user-chat-wrapper');
        const aiChatContainer = document.getElementById('ai-chat-container');
    const modeLabel = document.getElementById('mode-label');
    // single controls block (we'll move this between chat containers on mode switch)
    const chatControls = document.getElementById('chat-controls');
        let isAiMode = false;
        let typingTimeout = null;

        // --- USER CHAT (Original) ---
        let socket = null;
        const sendBtn = document.getElementById('sendBtn');
        const messageInput = document.getElementById('message');
        const allMessages = document.getElementById('messages');
        const userStatus = document.getElementById('user-status');

        // --- AI CHAT (New) ---
        const aiMessages = document.getElementById('ai-messages');
        const aiMessageInput = document.getElementById('ai-message-input');
        const aiSendBtn = document.getElementById('ai-send-btn');
        const aiUsername = document.getElementById('ai-username');
        const userFullnameEl = document.getElementById('user-fullname');
        const logoutBtn = document.getElementById('logoutBtn');


        // --- INITIALIZATION ---
        async function initializeChat() {
            console.log('[AUTH] Starting auth check...');
            try {
                const res = await fetch('/api/me');
                console.log('[AUTH] /api/me response status:', res.status);
                
                if (res.status === 200) {
                    const json = await res.json();
                    console.log('[AUTH] User authenticated:', json.user.username);
                    chatName = json.user.username;
                    
                    // Reveal chat UI now that we're authenticated
                    const wrapper = document.getElementById('user-chat-wrapper');
                    if (wrapper) {
                        wrapper.classList.remove('unauth-hidden');
                        console.log('[AUTH] Chat UI revealed');
                    }
                    
                    // show fullname in header
                    if (userFullnameEl) {
                        userFullnameEl.innerText = json.user.fullname || json.user.username;
                        console.log('[AUTH] Fullname displayed:', json.user.fullname);
                    }
                    
                    // --- User Chat Setup ---
                    sendBtn.disabled = false;
                    
                    // Initialize socket after auth
                    socket = io();
                    console.log('[AUTH] Socket.IO initialized');
                    attachSocketHandlers();
                    
                    // --- AI Chat Setup ---
                    aiUsername.innerText = json.user.fullname || chatName;
                    
                    // wire logout button
                    if (logoutBtn) {
                        logoutBtn.addEventListener('click', async () => {
                            console.log('[LOGOUT] Logout button clicked');
                            try {
                                const logoutRes = await fetch('/api/logout', { 
                                    method: 'POST', 
                                    credentials: 'same-origin' 
                                });
                                console.log('[LOGOUT] Logout response status:', logoutRes.status);
                            } catch (e) {
                                console.warn('[LOGOUT] Logout failed:', e);
                            }
                            console.log('[LOGOUT] Redirecting to login...');
                            window.location.href = '/login.html';
                        });
                        console.log('[AUTH] Logout button handler attached');
                    }
                } else {
                    console.log('[AUTH] Not authenticated (status ' + res.status + '), redirecting to login...');
                    window.location.href = '/login.html';
                }
            } catch (err) {
                console.error('[AUTH] Auth check failed:', err);
                window.location.href = '/login.html';
            }
        }

        initializeChat();

    // Ensure mode label reflects the current active mode on load
    modeLabel.innerText = isAiMode ? 'AI Chat' : 'User Chat';

        // --- DARK MODE TOGGLE ---
        darkModeToggle.addEventListener('change', () => {
            document.body.classList.toggle('dark');
        });

        // --- MODE TOGGLE ---
        modeToggle.addEventListener('change', () => {
            isAiMode = modeToggle.checked;
            if (isAiMode) {
                // Switch to AI Mode
                userChatWrapper.classList.add('hidden');
                aiChatContainer.classList.remove('hidden');
                aiChatContainer.classList.add('flex');
                document.body.classList.remove('user-chat-mode');
                document.body.classList.add('ai-chat-mode');
                // Move the controls into the AI chat inner panel (so they appear under the AI chat box)
                if (chatControls) {
                    const aiInner = aiChatContainer.querySelector('.w-full.max-w-2xl') || aiChatContainer.firstElementChild;
                    const aiInputRow = aiInner ? aiInner.querySelector('.mt-4') : null;
                    if (aiInner) {
                        if (aiInputRow) aiInner.insertBefore(chatControls, aiInputRow);
                        else aiInner.appendChild(chatControls);
                    }
                }
                // Show current selected mode
                modeLabel.innerText = "AI Chat";
            } else {
                // Switch to User Chat Mode
                userChatWrapper.classList.remove('hidden');
                aiChatContainer.classList.add('hidden');
                aiChatContainer.classList.remove('flex');
                document.body.classList.add('user-chat-mode');
                document.body.classList.remove('ai-chat-mode');
                // Move the controls back under the user chat card
                if (chatControls) {
                    const userInner = document.getElementById('chat-container');
                    const userInputRow = userInner ? userInner.querySelector('.mt-5') : null;
                    if (userInner) {
                        if (userInputRow) userInner.insertBefore(chatControls, userInputRow);
                        else userInner.appendChild(chatControls);
                    }
                }
                // Show current selected mode
                modeLabel.innerText = "User Chat";
            }
        });


        // --- USER CHAT LOGIC (Original) ---
        function attachSocketHandlers() {
            if (!socket) return;
            
            // Helper to format timestamp to IST
            function formatTimestamp(isoString) {
                if (!isoString) return '';
                try {
                    const date = new Date(isoString);
                    return date.toLocaleString('en-IN', { 
                        year: '2-digit',
                        month: '2-digit', 
                        day: '2-digit',
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: true,
                        timeZone: 'Asia/Kolkata'
                    });
                } catch (e) {
                    return '';
                }
            }
            
            // Helper to show notification
            function showNotification(title, options = {}) {
                if ('Notification' in window && Notification.permission === 'granted') {
                    try {
                        new Notification(title, { icon: '/favicon.ico', ...options });
                    } catch (e) {
                        console.log('[NOTIF] Notification failed:', e.message);
                    }
                }
            }
            
            socket.on('broadcast', (data) => {
                const p = document.createElement('p');
                const timestamp = data.timestamp ? `[${formatTimestamp(data.timestamp)}]` : '';
                p.innerHTML = `<strong>${data.name}</strong> ${timestamp}: ${escapeHtml(data.message)}`;
                p.style.marginBottom = '0.75rem';
                p.style.paddingBottom = '0.5rem';
                allMessages.appendChild(p);
                allMessages.scrollTop = allMessages.scrollHeight;
                
                // Show notification for new messages
                showNotification(`New message from ${data.name}`, { body: data.message });
            });
            
            socket.on('user-typing', (data) => {
                const typingEl = document.getElementById(`typing-${data.username}`);
                if (!typingEl) {
                    const typing = document.createElement('p');
                    typing.id = `typing-${data.username}`;
                    typing.innerHTML = `<em style="color: #999;">${escapeHtml(data.username)} is typing...</em>`;
                    allMessages.appendChild(typing);
                    allMessages.scrollTop = allMessages.scrollHeight;
                }
            });
            
            socket.on('user-stop-typing', (data) => {
                const typingEl = document.getElementById(`typing-${data.username}`);
                if (typingEl) typingEl.remove();
            });

            socket.on('update-users', (users) => {
                try {
                    // Remove only the user list items, keep the logout button
                    if (!userStatus) {
                        console.warn('[USERS] userStatus element is null/undefined');
                        return;
                    }
                    
                    const userItems = userStatus.querySelectorAll('.user');
                    userItems.forEach(item => item.remove());
                    
                    if (!Array.isArray(users)) {
                        console.warn('[USERS] users is not an array:', users);
                        return;
                    }
                    
                    users.forEach(user => {
                        const div = document.createElement('div');
                        div.className = 'user flex items-center mb-2';
                        
                        // Create avatar with colored background and first letter
                        const avatarColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
                        const avatarColor = avatarColors[user.charCodeAt(0) % avatarColors.length];
                        
                        const avatar = document.createElement('div');
                        avatar.className = 'user-avatar w-6 h-6 rounded-full flex items-center justify-center mr-2 text-xs font-bold text-white';
                        avatar.style.backgroundColor = avatarColor;
                        avatar.innerText = user.charAt(0).toUpperCase();
                        
                        const dot = document.createElement('div');
                        dot.className = 'user-dot h-2 w-2 bg-green-500 rounded-full mr-2';
                        
                        const name = document.createElement('span');
                        name.className = 'user-name text-sm font-semibold';
                        name.innerText = user;
                        
                        div.appendChild(avatar);
                        div.appendChild(dot);
                        div.appendChild(name);
                        userStatus.appendChild(div);
                    });
                } catch (err) {
                    console.error('[USERS] Error updating user list:', err);
                }
            });
        };

        messageInput.addEventListener('input', () => {
            sendBtn.disabled = !messageInput.value.trim();
            
            // Send typing indicator
            if (socket && messageInput.value.trim()) {
                socket.emit('typing', { name: chatName });
                
                // Clear previous timeout and set new one
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    socket.emit('stop-typing', { name: chatName });
                }, 2000);
            }
        });

        sendBtn.addEventListener('click', (e) => {
            const message = messageInput.value.trim();
            if (message) {
                // tiny send animation
                sendBtn.classList.add('sending');
                setTimeout(() => sendBtn.classList.remove('sending'), 420);

                socket.emit('user-message', { name: chatName, message });
                messageInput.value = '';
                sendBtn.disabled = true;
            }
        });
        
        // Also send on Enter key
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !sendBtn.disabled) {
                sendBtn.click();
            }
        });

        // (Moved into attachSocketHandlers so it's registered after socket init)

        // --- AI CHAT LOGIC (New) ---

        function appendAiMessage(sender, message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('ai-message', sender);
            
            const bubble = document.createElement('div');
            bubble.classList.add('bubble');
            
            // Convert markdown (like **text**) to HTML
            message = message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            // Convert newlines to <br>
            message = message.replace(/\n/g, '<br>');
            
            bubble.innerHTML = message;
            
            messageElement.appendChild(bubble);
            aiMessages.appendChild(messageElement);
            aiMessages.scrollTop = aiMessages.scrollHeight; // Auto-scroll
        }
        
        function showTypingIndicator() {
            const typingElement = document.createElement('div');
            typingElement.id = 'typing-indicator';
            typingElement.classList.add('ai-message', 'gemini', 'typing');
            typingElement.innerHTML = `
                <div class="bubble">
                    <span class="typing-dot"></span>
                    <span class="typing-dot"></span>
                    <span class="typing-dot"></span>
                </div>
            `;
            aiMessages.appendChild(typingElement);
            aiMessages.scrollTop = aiMessages.scrollHeight;
        }

        function removeTypingIndicator() {
            const typingElement = document.getElementById('typing-indicator');
            if (typingElement) {
                typingElement.remove();
            }
        }

        async function handleAiChatSend() {
            const prompt = aiMessageInput.value.trim();
            if (!prompt) return;

            // Display user message
            appendAiMessage('user', prompt);
            aiMessageInput.value = '';
            aiSendBtn.disabled = true;
            aiSendBtn.classList.add('sending');

            // Show typing indicator
            showTypingIndicator();

            try {
                // Call Gemini API
                const result = await callGeminiApi(prompt);
                removeTypingIndicator();
                appendAiMessage('gemini', result.text);
            } catch (error) {
                removeTypingIndicator();
                console.error('Error calling Gemini API:', error);
                appendAiMessage('gemini', `Sorry, I ran into an error. Please try again. \n(${error.message})`);
            }
            aiSendBtn.disabled = false;
            aiSendBtn.classList.remove('sending');
        }

        aiSendBtn.addEventListener('click', handleAiChatSend);
        aiMessageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleAiChatSend();
            }
        });

        // --- GEMINI API CALL (server-side proxy) ---
        // This function calls our server endpoint which holds the API key.
        async function callGeminiApi(prompt, retries = 3, delay = 1000) {
            if (!prompt) throw new Error('Missing prompt');

            const payload = { prompt };

            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch('/api/gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });

                    if (!response.ok) {
                        const text = await response.text();
                        throw new Error(`Server Error: ${response.status} ${response.statusText} - ${text}`);
                    }

                    const result = await response.json();
                    if (result && result.text) {
                        return { text: result.text };
                    }

                    throw new Error(result.error || 'No content returned from server');
                } catch (err) {
                    console.warn(`Client Gemini attempt ${i + 1} failed:`, err.message || err);
                    if (i === retries - 1) throw err;
                    await new Promise(r => setTimeout(r, delay));
                    delay *= 2;
                }
            }
            throw new Error('Failed to get response after all retries.');
        }

    </script>

    <!-- Mobile Panel Controller -->
    <script>
        // Initialize mobile menu after DOM is fully loaded
        function initMobileMenu() {
            console.log('[MOBILE] initMobileMenu called');
            const menuToggle = document.getElementById('mobile-menu-toggle');
            const userStatusPanel = document.getElementById('user-status');
            const overlay = document.getElementById('mobile-overlay');
            const closePanel = document.getElementById('close-status-panel');

            console.log('[MOBILE] Elements found:', {
                menuToggle: !!menuToggle,
                userStatusPanel: !!userStatusPanel,
                overlay: !!overlay,
                closePanel: !!closePanel
            });

            if (!menuToggle || !userStatusPanel || !overlay || !closePanel) {
                console.warn('[MOBILE] Mobile menu elements not found');
                return;
            }

            // Open panel on menu button click
            menuToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                userStatusPanel.classList.add('active');
                overlay.classList.add('active');
            });

            // Close panel on close button click
            closePanel.addEventListener('click', (e) => {
                e.stopPropagation();
                userStatusPanel.classList.remove('active');
                overlay.classList.remove('active');
            });

            // Close panel on overlay click
            overlay.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log('[MOBILE] Overlay clicked');
                userStatusPanel.classList.remove('active');
                overlay.classList.remove('active');
            });

            // Close panel when window resizes to desktop size (> 768px)
            window.addEventListener('resize', () => {
                if (window.innerWidth > 768) {
                    userStatusPanel.classList.remove('active');
                    overlay.classList.remove('active');
                }
            });

            console.log('[MOBILE] Mobile menu initialized successfully');
        }

        // Run when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initMobileMenu);
        } else {
            initMobileMenu();
        }
    </script>
</body>
</html>